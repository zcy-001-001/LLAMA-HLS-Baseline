# --- 保留 Debug 和 Temps 设置 ---
debug=1
save-temps=1

[connectivity]
# --- 计算单元定义  ---
nk=initial_embedding_lookup:1:init_embed_1
nk=transformer_layer_pipeline:1:layer_pipeline_1 # ADDED - 新 Kernel 实例
nk=final_norm_classifier:1:final_norm_1

# --- SLR 分配 (修改) ---

# --- SLR 分配 (修改) ---

slr=init_embed_1:SLR1
slr=layer_pipeline_1:SLR0 
slr=final_norm_1:SLR1

# --- HBM 映射 (修改) ---
# --- (new) 最大化总带宽的核心思想就是尽可能地让更多的 通道 同时处于活动状态。---
sp=init_embed_1.token_embedding_table:HBM[1]

sp=layer_pipeline_1.value_cache:HBM[4] # UPDATED - 指向新 Kernel 实例
sp=layer_pipeline_1.key_cache:HBM[5]   # UPDATED - 指向新 Kernel 实例
sp=layer_pipeline_1.w:HBM[6:10]# UPDATED - 指向新 Kernel 实例并合并 HBM 范围
sp=layer_pipeline_1.w_ffn:HBM[17:21]# UPDATED - 指向新 Kernel 实例并合并 HBM 范围

sp=final_norm_1.w:HBM[26:30]
sp=final_norm_1.logits_out:HBM[25]

# --- Stream 连接 (修改) ---
#当前深度为 32。虽然不绝对大，但在拥塞区域，即使是中等大小的 FIFO 也可能难以布线。生产者和消费者都是块传输（先读/写完 dim 个再做别的），也许不需要这么深的缓冲，尤其是在它们处理速度匹配的情况下。
# 连接 1: initial_embedding_lookup 的输出流 连接到 transformer_layer_pipeline 的输入流
stream_connect=init_embed_1.stream_out_x:layer_pipeline_1.s_initial_in
# 连接 2: transformer_layer_pipeline 的输出流 连接到 final_norm_classifier 的输入流
stream_connect=layer_pipeline_1.s_final_out:final_norm_1.stream_in_x


# --- Profile 设置保持不变 ---
[profile]
data=all:all:all